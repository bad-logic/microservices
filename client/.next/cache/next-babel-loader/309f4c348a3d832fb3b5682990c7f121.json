{"ast":null,"code":"var _jsxFileName = \"/usr/app/pages/index.js\";\nimport React from \"react\";\nvar __jsx = React.createElement;\nimport Link from 'next/link';\n\nconst index = ({\n  currentUser,\n  tickets\n}) => {\n  const tableContent = tickets.map(t => {\n    return __jsx(\"tr\", {\n      key: t.id,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 7,\n        columnNumber: 17\n      }\n    }, __jsx(\"td\", {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 8,\n        columnNumber: 21\n      }\n    }, t.title), __jsx(\"td\", {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 9,\n        columnNumber: 21\n      }\n    }, t.price), __jsx(\"td\", {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 10,\n        columnNumber: 21\n      }\n    }, __jsx(Link, {\n      href: `/tickets/${t.id}`,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 11,\n        columnNumber: 21\n      }\n    }, __jsx(\"a\", {\n      className: \"nav-link\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 12,\n        columnNumber: 29\n      }\n    }, \"Click here\"))));\n  });\n  return __jsx(\"div\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 22,\n      columnNumber: 13\n    }\n  }, __jsx(\"h1\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 23,\n      columnNumber: 17\n    }\n  }, \"Tickets\"), __jsx(\"table\", {\n    className: \"table\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 24,\n      columnNumber: 17\n    }\n  }, __jsx(\"thead\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 25,\n      columnNumber: 21\n    }\n  }, __jsx(\"tr\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 26,\n      columnNumber: 25\n    }\n  }, __jsx(\"th\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 27,\n      columnNumber: 29\n    }\n  }, \"Title\"), __jsx(\"th\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 28,\n      columnNumber: 29\n    }\n  }, \"Price\"), __jsx(\"th\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 29,\n      columnNumber: 29\n    }\n  }, \"Link\"))), __jsx(\"tbody\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 32,\n      columnNumber: 21\n    }\n  }, tableContent)));\n};\n\nindex.getInitialProps = async (context, client, currentUser) => {\n  const data = await client.get('/api/ticket/v1/get-tickets');\n  return {\n    tickets: data.data.tickets\n  };\n};\n\nexport default index; // IF YOU ARE RUNNING YOUR NEXTJS SERVER IN A DIFFERENT DOMAIN OR DIF KUBERNETES CLUSTER\n// AND SERVICES IN ANOTHER DOMAIN OR K-CLUSTER THEN WE WILL HAVE DIFFERENT DOMAIN FOR \n// SERVICES AND CLIENT IN SUCH CASE WE DON'T NEED TO WORRY ABOUT WHO EXECUTES getInitialProps\n// FUNCTION SINCE IN BOTH CASES WE SEND REQUEST TO SAME DOMAIN WHICH IS DIFFERENT FROM THE \n// CLIENT DOMAIN\n// THIS ISSUE IS ONLY KUBERNETES RELATED\n// NOTE\n// ANY REQUEST FROM INSIDE THE REACT COMPONENT WILL BE ISSUED BY THE CLIENT BROWSER\n// ANY REQUEST INSIDE GETINITIALPROPS MAY BE EXECUTED FROM BOTH SERVER OR THE CLIENT BROWSER\n// GETINITIALPROPS\n// CASE: INITIATED BY NEXTJS SERVER\n// 1. ON HARD REFRESH \n// 2. CLICKING THE LINK FROM DIFFERENT DOMAIN\n// 3. TYPING URL INTO ADDRESS BAR\n// CASE: INITIATED BY CLIENT BROWSER\n// NAVIGATING OR ROUTING FROM ONE PAGE TO ANOTHER WHILE INSIDE THE APP\n// if this network request is made from next js server running inside the kubernetes cluster\n// and next js server is also running in the same cluster then we need to connect to the\n// auth service from the nextjs server\n// TWO WAYS TO CONNECT BETWEEN NEXTJS SERVER AND AUTH SERVICE\n// first since they are in same cluster and within same namespace we could simply\n// connect using their clusterip service name but with the risk of exposing the\n// info about our cluster services to the client\n// second solution will be to call the ingress-nginx from nextjs server which contains \n// all the logic that will route us to the corresponding service automatically\n// but the ingress-nginx is created in diff namespace than our services which are\n// created in default namespace. service within same namespace can be accessed with service name\n// but cross namespace communication is a different case\n// CROSS NAMESPACE COMMUNICATION CAN BE DONE AS\n// http://service-name.namespace-name.svc.cluster.local;\n// or if this syntax is difficult to remember you can also create a external service name\n// that maps to this long name\n// BELOW CASE ORIGINATES ONLY WHEN THE BROWSER HAS STORED COOKIES FOR THAT DOMAIN\n// IF NO COOKIES FOR THAT DOMAIN ARE STORED THEN WE DON'T HAVE TO WORRY ABOUT IT\n// Another issue we are going to run into when network request done by nextjs server is cookies\n// cookies are sent automatically on each request by the browser\n// so on the request for the index.js page the browser sends cookie in the headers to nextjs server\n// thus we need a way to catch this cookie and forward it to the auth service current-user route\n// which depends on the cookies to return the current user\n//  index.getInitialProps = async ({req})=>{\n//      let res;\n//      if(typeof window === 'undefined' ){\n//          // window object exists only inside the browser\n//          // so code inside this block will not be executed by browser\n//          // res = await axios.get('http://ingress-nginx-controller-admission.kube-system.svc.cluster.local/api/auth/v1/current-user');\n//          // above will not work since ingress-nginx may have diff routing rules for different domains\n//          // so we also need to specify domain names and ingress-nginx will know which domain rules\n//          // to apply for routing\n//          // const cookie = req.get('Set-Cookie');\n//         // res = await axios.get(\n//         //     `http://ingress-nginx-controller-admission.kube-system.svc.cluster.local/api/auth/v1/current-user`,\n//         //     {\n//         //         headers:{\n//         //             Host:'tickets.dev'\n//         //         }\n//         //     }\n//         // );\n//         res = await axios.get(\n//             `http://ingress-nginx-controller-admission.kube-system.svc.cluster.local/api/auth/v1/current-user`,\n//             {\n//                 headers: req.headers //  headers includes hosts cookies and all \n//             }\n//         );\n//     }else{\n//         // below code will be executed by the browser only\n//         res = await axios.get('/api/auth/v1/current-user');\n//         // the above request won't work if executed by nextjs server. \n//         // if there is no host address then the axios will  add the current host address \n//         // in this case it is localhost=> which is the container that is running \n//         // nextjs server inside kubernetes cluster. so it will reach out to\n//         // localhost:80/api/auth/v1/current-user. port 80 since we didn't specify port \n//         // it will use 80 by default and inside that container we don't have any\n//         // service listening at port 80\n//     }     \n//     return res.data;\n//  }","map":{"version":3,"sources":["/usr/app/pages/index.js"],"names":["Link","index","currentUser","tickets","tableContent","map","t","id","title","price","getInitialProps","context","client","data","get"],"mappings":";;;AAAA,OAAOA,IAAP,MAAiB,WAAjB;;AAEA,MAAMC,KAAK,GAAG,CAAC;AAACC,EAAAA,WAAD;AAAaC,EAAAA;AAAb,CAAD,KAAyB;AAEnC,QAAMC,YAAY,GAAGD,OAAO,CAACE,GAAR,CAAYC,CAAC,IAAE;AAC5B,WACI;AAAI,MAAA,GAAG,EAAEA,CAAC,CAACC,EAAX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OACI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAAKD,CAAC,CAACE,KAAP,CADJ,EAEI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAAKF,CAAC,CAACG,KAAP,CAFJ,EAGI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OACA,MAAC,IAAD;AAAM,MAAA,IAAI,EAAG,YAAWH,CAAC,CAACC,EAAG,EAA7B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OACQ;AAAG,MAAA,SAAS,EAAC,UAAb;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,oBADR,CADA,CAHJ,CADJ;AAWH,GAZgB,CAArB;AAgBA,SACQ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KACI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,eADJ,EAEI;AAAO,IAAA,SAAS,EAAC,OAAjB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KACI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KACI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KACI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,aADJ,EAEI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,aAFJ,EAGI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,YAHJ,CADJ,CADJ,EAQI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KACKH,YADL,CARJ,CAFJ,CADR;AAiBH,CAnCD;;AAwCAH,KAAK,CAACS,eAAN,GAAwB,OAAOC,OAAP,EAAeC,MAAf,EAAsBV,WAAtB,KAAoC;AACxD,QAAMW,IAAI,GAAG,MAAMD,MAAM,CAACE,GAAP,CAAW,4BAAX,CAAnB;AACA,SAAO;AAACX,IAAAA,OAAO,EAACU,IAAI,CAACA,IAAL,CAAUV;AAAnB,GAAP;AACH,CAHD;;AAOA,eAAeF,KAAf,C,CAWA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["import Link from 'next/link';\n\nconst index = ({currentUser,tickets})=>{\n    \n    const tableContent = tickets.map(t=>{\n            return (\n                <tr key={t.id}>\n                    <td>{t.title}</td>\n                    <td>{t.price}</td>\n                    <td>\n                    <Link href={`/tickets/${t.id}`}>\n                            <a className=\"nav-link\">Click here</a>\n                    </Link>\n                    </td>\n                </tr>\n            );\n        });\n\n\n\n    return (\n            <div>\n                <h1>Tickets</h1>\n                <table className=\"table\">\n                    <thead>\n                        <tr>\n                            <th>Title</th>\n                            <th>Price</th>\n                            <th>Link</th>\n                        </tr>\n                    </thead>\n                    <tbody>\n                        {tableContent}\n                    </tbody>\n                </table>\n            </div>\n        );\n}; \n\n\n\n\nindex.getInitialProps = async (context,client,currentUser)=>{\n    const data = await client.get('/api/ticket/v1/get-tickets');\n    return {tickets:data.data.tickets};\n}\n\n\n\nexport default index;\n\n\n\n\n\n\n\n\n\n\n// IF YOU ARE RUNNING YOUR NEXTJS SERVER IN A DIFFERENT DOMAIN OR DIF KUBERNETES CLUSTER\n// AND SERVICES IN ANOTHER DOMAIN OR K-CLUSTER THEN WE WILL HAVE DIFFERENT DOMAIN FOR \n// SERVICES AND CLIENT IN SUCH CASE WE DON'T NEED TO WORRY ABOUT WHO EXECUTES getInitialProps\n// FUNCTION SINCE IN BOTH CASES WE SEND REQUEST TO SAME DOMAIN WHICH IS DIFFERENT FROM THE \n// CLIENT DOMAIN\n\n// THIS ISSUE IS ONLY KUBERNETES RELATED\n// NOTE\n// ANY REQUEST FROM INSIDE THE REACT COMPONENT WILL BE ISSUED BY THE CLIENT BROWSER\n// ANY REQUEST INSIDE GETINITIALPROPS MAY BE EXECUTED FROM BOTH SERVER OR THE CLIENT BROWSER\n// GETINITIALPROPS\n\n// CASE: INITIATED BY NEXTJS SERVER\n// 1. ON HARD REFRESH \n// 2. CLICKING THE LINK FROM DIFFERENT DOMAIN\n// 3. TYPING URL INTO ADDRESS BAR\n\n// CASE: INITIATED BY CLIENT BROWSER\n// NAVIGATING OR ROUTING FROM ONE PAGE TO ANOTHER WHILE INSIDE THE APP\n// if this network request is made from next js server running inside the kubernetes cluster\n// and next js server is also running in the same cluster then we need to connect to the\n// auth service from the nextjs server\n// TWO WAYS TO CONNECT BETWEEN NEXTJS SERVER AND AUTH SERVICE\n\n// first since they are in same cluster and within same namespace we could simply\n// connect using their clusterip service name but with the risk of exposing the\n// info about our cluster services to the client\n\n// second solution will be to call the ingress-nginx from nextjs server which contains \n// all the logic that will route us to the corresponding service automatically\n// but the ingress-nginx is created in diff namespace than our services which are\n// created in default namespace. service within same namespace can be accessed with service name\n// but cross namespace communication is a different case\n\n// CROSS NAMESPACE COMMUNICATION CAN BE DONE AS\n// http://service-name.namespace-name.svc.cluster.local;\n// or if this syntax is difficult to remember you can also create a external service name\n// that maps to this long name\n\n\n// BELOW CASE ORIGINATES ONLY WHEN THE BROWSER HAS STORED COOKIES FOR THAT DOMAIN\n// IF NO COOKIES FOR THAT DOMAIN ARE STORED THEN WE DON'T HAVE TO WORRY ABOUT IT\n\n// Another issue we are going to run into when network request done by nextjs server is cookies\n// cookies are sent automatically on each request by the browser\n// so on the request for the index.js page the browser sends cookie in the headers to nextjs server\n// thus we need a way to catch this cookie and forward it to the auth service current-user route\n// which depends on the cookies to return the current user\n\n//  index.getInitialProps = async ({req})=>{\n//      let res;\n//      if(typeof window === 'undefined' ){\n//          // window object exists only inside the browser\n//          // so code inside this block will not be executed by browser\n//          // res = await axios.get('http://ingress-nginx-controller-admission.kube-system.svc.cluster.local/api/auth/v1/current-user');\n         \n//          // above will not work since ingress-nginx may have diff routing rules for different domains\n//          // so we also need to specify domain names and ingress-nginx will know which domain rules\n//          // to apply for routing\n//          // const cookie = req.get('Set-Cookie');\n         \n//         // res = await axios.get(\n//         //     `http://ingress-nginx-controller-admission.kube-system.svc.cluster.local/api/auth/v1/current-user`,\n//         //     {\n//         //         headers:{\n//         //             Host:'tickets.dev'\n//         //         }\n//         //     }\n//         // );\n//         res = await axios.get(\n//             `http://ingress-nginx-controller-admission.kube-system.svc.cluster.local/api/auth/v1/current-user`,\n//             {\n//                 headers: req.headers //  headers includes hosts cookies and all \n//             }\n//         );\n//     }else{\n//         // below code will be executed by the browser only\n//         res = await axios.get('/api/auth/v1/current-user');\n//         // the above request won't work if executed by nextjs server. \n//         // if there is no host address then the axios will  add the current host address \n//         // in this case it is localhost=> which is the container that is running \n//         // nextjs server inside kubernetes cluster. so it will reach out to\n//         // localhost:80/api/auth/v1/current-user. port 80 since we didn't specify port \n//         // it will use 80 by default and inside that container we don't have any\n//         // service listening at port 80\n//     }     \n//     return res.data;\n//  }"]},"metadata":{},"sourceType":"module"}