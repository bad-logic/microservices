{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\n\nvar _this = this,\n    _jsxFileName = \"/usr/app/pages/index.js\";\n\nimport React from \"react\";\nvar __jsx = React.createElement;\n\nvar index = function index(_ref) {\n  var currentUser = _ref.currentUser;\n  console.log('cu user', currentUser);\n  return __jsx(\"h1\", {\n    __self: _this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 4,\n      columnNumber: 12\n    }\n  }, \"Index \", currentUser ? 'SignedIn' : 'sign in');\n};\n\nindex.getInitialProps = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(context, client, currentUser) {\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            return _context.abrupt(\"return\", {});\n\n          case 1:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function (_x, _x2, _x3) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\nexport default index; // IF YOU ARE RUNNING YOUR NEXTJS SERVER IN A DIFFERENT DOMAIN OR DIF KUBERNETES CLUSTER\n// AND SERVICES IN ANOTHER DOMAIN OR K-CLUSTER THEN WE WILL HAVE DIFFERENT DOMAIN FOR \n// SERVICES AND CLIENT IN SUCH CASE WE DON'T NEED TO WORRY ABOUT WHO EXECUTES getInitialProps\n// FUNCTION SINCE IN BOTH CASES WE SEND REQUEST TO SAME DOMAIN WHICH IS DIFFERENT FROM THE \n// CLIENT DOMAIN\n// THIS ISSUE IS ONLY KUBERNETES RELATED\n// NOTE\n// ANY REQUEST FROM INSIDE THE REACT COMPONENT WILL BE ISSUED BY THE CLIENT BROWSER\n// ANY REQUEST INSIDE GETINITIALPROPS MAY BE EXECUTED FROM BOTH SERVER OR THE CLIENT BROWSER\n// GETINITIALPROPS\n// CASE: INITIATED BY NEXTJS SERVER\n// 1. ON HARD REFRESH \n// 2. CLICKING THE LINK FROM DIFFERENT DOMAIN\n// 3. TYPING URL INTO ADDRESS BAR\n// CASE: INITIATED BY CLIENT BROWSER\n// NAVIGATING OR ROUTING FROM ONE PAGE TO ANOTHER WHILE INSIDE THE APP\n// if this network request is made from next js server running inside the kubernetes cluster\n// and next js server is also running in the same cluster then we need to connect to the\n// auth service from the nextjs server\n// TWO WAYS TO CONNECT BETWEEN NEXTJS SERVER AND AUTH SERVICE\n// first since they are in same cluster and within same namespace we could simply\n// connect using their clusterip service name but with the risk of exposing the\n// info about our cluster services to the client\n// second solution will be to call the ingress-nginx from nextjs server which contains \n// all the logic that will route us to the corresponding service automatically\n// but the ingress-nginx is created in diff namespace than our services which are\n// created in default namespace. service within same namespace can be accessed with service name\n// but cross namespace communication is a different case\n// CROSS NAMESPACE COMMUNICATION CAN BE DONE AS\n// http://service-name.namespace-name.svc.cluster.local;\n// or if this syntax is difficult to remember you can also create a external service name\n// that maps to this long name\n// BELOW CASE ORIGINATES ONLY WHEN THE BROWSER HAS STORED COOKIES FOR THAT DOMAIN\n// IF NO COOKIES FOR THAT DOMAIN ARE STORED THEN WE DON'T HAVE TO WORRY ABOUT IT\n// Another issue we are going to run into when network request done by nextjs server is cookies\n// cookies are sent automatically on each request by the browser\n// so on the request for the index.js page the browser sends cookie in the headers to nextjs server\n// thus we need a way to catch this cookie and forward it to the auth service current-user route\n// which depends on the cookies to return the current user\n//  index.getInitialProps = async ({req})=>{\n//      let res;\n//      if(typeof window === 'undefined' ){\n//          // window object exists only inside the browser\n//          // so code inside this block will not be executed by browser\n//          // res = await axios.get('http://ingress-nginx-controller-admission.kube-system.svc.cluster.local/api/auth/v1/current-user');\n//          // above will not work since ingress-nginx may have diff routing rules for different domains\n//          // so we also need to specify domain names and ingress-nginx will know which domain rules\n//          // to apply for routing\n//          // const cookie = req.get('Set-Cookie');\n//         // res = await axios.get(\n//         //     `http://ingress-nginx-controller-admission.kube-system.svc.cluster.local/api/auth/v1/current-user`,\n//         //     {\n//         //         headers:{\n//         //             Host:'tickets.dev'\n//         //         }\n//         //     }\n//         // );\n//         res = await axios.get(\n//             `http://ingress-nginx-controller-admission.kube-system.svc.cluster.local/api/auth/v1/current-user`,\n//             {\n//                 headers: req.headers //  headers includes hosts cookies and all \n//             }\n//         );\n//     }else{\n//         // below code will be executed by the browser only\n//         res = await axios.get('/api/auth/v1/current-user');\n//         // the above request won't work if executed by nextjs server. \n//         // if there is no host address then the axios will  add the current host address \n//         // in this case it is localhost=> which is the container that is running \n//         // nextjs server inside kubernetes cluster. so it will reach out to\n//         // localhost:80/api/auth/v1/current-user. port 80 since we didn't specify port \n//         // it will use 80 by default and inside that container we don't have any\n//         // service listening at port 80\n//     }     \n//     return res.data;\n//  }","map":{"version":3,"sources":["/usr/app/pages/index.js"],"names":["index","currentUser","console","log","getInitialProps","context","client"],"mappings":";;;;;;;;;AACA,IAAMA,KAAK,GAAG,SAARA,KAAQ,OAAiB;AAAA,MAAfC,WAAe,QAAfA,WAAe;AAC3BC,EAAAA,OAAO,CAACC,GAAR,CAAY,SAAZ,EAAsBF,WAAtB;AACA,SAAO;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,eAAWA,WAAW,GAAG,UAAH,GAAgB,SAAtC,CAAP;AACH,CAHD;;AAMAD,KAAK,CAACI,eAAN;AAAA,uEAAwB,iBAAOC,OAAP,EAAeC,MAAf,EAAsBL,WAAtB;AAAA;AAAA;AAAA;AAAA;AAAA,6CACb,EADa;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAAxB;;AAAA;AAAA;AAAA;AAAA;;AAGA,eAAeD,KAAf,C,CAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["\nconst index = ({currentUser})=>{\n    console.log('cu user',currentUser);\n    return <h1>Index {currentUser ? 'SignedIn' : 'sign in'}</h1>\n}; \n\n\nindex.getInitialProps = async (context,client,currentUser)=>{\n    return {};\n}\nexport default index;\n\n// IF YOU ARE RUNNING YOUR NEXTJS SERVER IN A DIFFERENT DOMAIN OR DIF KUBERNETES CLUSTER\n// AND SERVICES IN ANOTHER DOMAIN OR K-CLUSTER THEN WE WILL HAVE DIFFERENT DOMAIN FOR \n// SERVICES AND CLIENT IN SUCH CASE WE DON'T NEED TO WORRY ABOUT WHO EXECUTES getInitialProps\n// FUNCTION SINCE IN BOTH CASES WE SEND REQUEST TO SAME DOMAIN WHICH IS DIFFERENT FROM THE \n// CLIENT DOMAIN\n\n// THIS ISSUE IS ONLY KUBERNETES RELATED\n// NOTE\n// ANY REQUEST FROM INSIDE THE REACT COMPONENT WILL BE ISSUED BY THE CLIENT BROWSER\n// ANY REQUEST INSIDE GETINITIALPROPS MAY BE EXECUTED FROM BOTH SERVER OR THE CLIENT BROWSER\n// GETINITIALPROPS\n\n// CASE: INITIATED BY NEXTJS SERVER\n// 1. ON HARD REFRESH \n// 2. CLICKING THE LINK FROM DIFFERENT DOMAIN\n// 3. TYPING URL INTO ADDRESS BAR\n\n// CASE: INITIATED BY CLIENT BROWSER\n// NAVIGATING OR ROUTING FROM ONE PAGE TO ANOTHER WHILE INSIDE THE APP\n// if this network request is made from next js server running inside the kubernetes cluster\n// and next js server is also running in the same cluster then we need to connect to the\n// auth service from the nextjs server\n// TWO WAYS TO CONNECT BETWEEN NEXTJS SERVER AND AUTH SERVICE\n\n// first since they are in same cluster and within same namespace we could simply\n// connect using their clusterip service name but with the risk of exposing the\n// info about our cluster services to the client\n\n// second solution will be to call the ingress-nginx from nextjs server which contains \n// all the logic that will route us to the corresponding service automatically\n// but the ingress-nginx is created in diff namespace than our services which are\n// created in default namespace. service within same namespace can be accessed with service name\n// but cross namespace communication is a different case\n\n// CROSS NAMESPACE COMMUNICATION CAN BE DONE AS\n// http://service-name.namespace-name.svc.cluster.local;\n// or if this syntax is difficult to remember you can also create a external service name\n// that maps to this long name\n\n\n// BELOW CASE ORIGINATES ONLY WHEN THE BROWSER HAS STORED COOKIES FOR THAT DOMAIN\n// IF NO COOKIES FOR THAT DOMAIN ARE STORED THEN WE DON'T HAVE TO WORRY ABOUT IT\n\n// Another issue we are going to run into when network request done by nextjs server is cookies\n// cookies are sent automatically on each request by the browser\n// so on the request for the index.js page the browser sends cookie in the headers to nextjs server\n// thus we need a way to catch this cookie and forward it to the auth service current-user route\n// which depends on the cookies to return the current user\n\n//  index.getInitialProps = async ({req})=>{\n//      let res;\n//      if(typeof window === 'undefined' ){\n//          // window object exists only inside the browser\n//          // so code inside this block will not be executed by browser\n//          // res = await axios.get('http://ingress-nginx-controller-admission.kube-system.svc.cluster.local/api/auth/v1/current-user');\n         \n//          // above will not work since ingress-nginx may have diff routing rules for different domains\n//          // so we also need to specify domain names and ingress-nginx will know which domain rules\n//          // to apply for routing\n//          // const cookie = req.get('Set-Cookie');\n         \n//         // res = await axios.get(\n//         //     `http://ingress-nginx-controller-admission.kube-system.svc.cluster.local/api/auth/v1/current-user`,\n//         //     {\n//         //         headers:{\n//         //             Host:'tickets.dev'\n//         //         }\n//         //     }\n//         // );\n//         res = await axios.get(\n//             `http://ingress-nginx-controller-admission.kube-system.svc.cluster.local/api/auth/v1/current-user`,\n//             {\n//                 headers: req.headers //  headers includes hosts cookies and all \n//             }\n//         );\n//     }else{\n//         // below code will be executed by the browser only\n//         res = await axios.get('/api/auth/v1/current-user');\n//         // the above request won't work if executed by nextjs server. \n//         // if there is no host address then the axios will  add the current host address \n//         // in this case it is localhost=> which is the container that is running \n//         // nextjs server inside kubernetes cluster. so it will reach out to\n//         // localhost:80/api/auth/v1/current-user. port 80 since we didn't specify port \n//         // it will use 80 by default and inside that container we don't have any\n//         // service listening at port 80\n//     }     \n//     return res.data;\n//  }"]},"metadata":{},"sourceType":"module"}