{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\n\nvar _this = this,\n    _jsxFileName = \"/usr/app/pages/index.js\";\n\nimport React from \"react\";\nvar __jsx = React.createElement;\n\nvar index = function index(_ref) {\n  var currentUser = _ref.currentUser,\n      tickets = _ref.tickets;\n\n  var getContent = function getContent() {\n    return tickets.map(function (t) {\n      return __jsx(\"tr\", {\n        key: t.id,\n        __self: _this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 6,\n          columnNumber: 21\n        }\n      }, __jsx(\"td\", {\n        __self: _this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 7,\n          columnNumber: 17\n        }\n      }, t.title), __jsx(\"td\", {\n        __self: _this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 8,\n          columnNumber: 17\n        }\n      }, t.price));\n    });\n  };\n\n  return __jsx(\"div\", {\n    __self: _this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 13,\n      columnNumber: 13\n    }\n  }, __jsx(\"h1\", {\n    __self: _this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 14,\n      columnNumber: 17\n    }\n  }, \"Tickets\"), __jsx(\"table\", {\n    className: \"table\",\n    __self: _this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 15,\n      columnNumber: 17\n    }\n  }, __jsx(\"thead\", {\n    __self: _this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 16,\n      columnNumber: 21\n    }\n  }, __jsx(\"tr\", {\n    __self: _this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 17,\n      columnNumber: 25\n    }\n  }, __jsx(\"th\", {\n    __self: _this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 18,\n      columnNumber: 29\n    }\n  }, \"Title\"), __jsx(\"th\", {\n    __self: _this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 19,\n      columnNumber: 29\n    }\n  }, \"Price\")), getContent())));\n};\n\nindex.getInitialProps = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(context, client, currentUser) {\n    var data;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return client.get('/api/ticket/v1/get-tickets');\n\n          case 2:\n            data = _context.sent;\n            return _context.abrupt(\"return\", {\n              tickets: data.data.tickets\n            });\n\n          case 4:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function (_x, _x2, _x3) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\nexport default index; // IF YOU ARE RUNNING YOUR NEXTJS SERVER IN A DIFFERENT DOMAIN OR DIF KUBERNETES CLUSTER\n// AND SERVICES IN ANOTHER DOMAIN OR K-CLUSTER THEN WE WILL HAVE DIFFERENT DOMAIN FOR \n// SERVICES AND CLIENT IN SUCH CASE WE DON'T NEED TO WORRY ABOUT WHO EXECUTES getInitialProps\n// FUNCTION SINCE IN BOTH CASES WE SEND REQUEST TO SAME DOMAIN WHICH IS DIFFERENT FROM THE \n// CLIENT DOMAIN\n// THIS ISSUE IS ONLY KUBERNETES RELATED\n// NOTE\n// ANY REQUEST FROM INSIDE THE REACT COMPONENT WILL BE ISSUED BY THE CLIENT BROWSER\n// ANY REQUEST INSIDE GETINITIALPROPS MAY BE EXECUTED FROM BOTH SERVER OR THE CLIENT BROWSER\n// GETINITIALPROPS\n// CASE: INITIATED BY NEXTJS SERVER\n// 1. ON HARD REFRESH \n// 2. CLICKING THE LINK FROM DIFFERENT DOMAIN\n// 3. TYPING URL INTO ADDRESS BAR\n// CASE: INITIATED BY CLIENT BROWSER\n// NAVIGATING OR ROUTING FROM ONE PAGE TO ANOTHER WHILE INSIDE THE APP\n// if this network request is made from next js server running inside the kubernetes cluster\n// and next js server is also running in the same cluster then we need to connect to the\n// auth service from the nextjs server\n// TWO WAYS TO CONNECT BETWEEN NEXTJS SERVER AND AUTH SERVICE\n// first since they are in same cluster and within same namespace we could simply\n// connect using their clusterip service name but with the risk of exposing the\n// info about our cluster services to the client\n// second solution will be to call the ingress-nginx from nextjs server which contains \n// all the logic that will route us to the corresponding service automatically\n// but the ingress-nginx is created in diff namespace than our services which are\n// created in default namespace. service within same namespace can be accessed with service name\n// but cross namespace communication is a different case\n// CROSS NAMESPACE COMMUNICATION CAN BE DONE AS\n// http://service-name.namespace-name.svc.cluster.local;\n// or if this syntax is difficult to remember you can also create a external service name\n// that maps to this long name\n// BELOW CASE ORIGINATES ONLY WHEN THE BROWSER HAS STORED COOKIES FOR THAT DOMAIN\n// IF NO COOKIES FOR THAT DOMAIN ARE STORED THEN WE DON'T HAVE TO WORRY ABOUT IT\n// Another issue we are going to run into when network request done by nextjs server is cookies\n// cookies are sent automatically on each request by the browser\n// so on the request for the index.js page the browser sends cookie in the headers to nextjs server\n// thus we need a way to catch this cookie and forward it to the auth service current-user route\n// which depends on the cookies to return the current user\n//  index.getInitialProps = async ({req})=>{\n//      let res;\n//      if(typeof window === 'undefined' ){\n//          // window object exists only inside the browser\n//          // so code inside this block will not be executed by browser\n//          // res = await axios.get('http://ingress-nginx-controller-admission.kube-system.svc.cluster.local/api/auth/v1/current-user');\n//          // above will not work since ingress-nginx may have diff routing rules for different domains\n//          // so we also need to specify domain names and ingress-nginx will know which domain rules\n//          // to apply for routing\n//          // const cookie = req.get('Set-Cookie');\n//         // res = await axios.get(\n//         //     `http://ingress-nginx-controller-admission.kube-system.svc.cluster.local/api/auth/v1/current-user`,\n//         //     {\n//         //         headers:{\n//         //             Host:'tickets.dev'\n//         //         }\n//         //     }\n//         // );\n//         res = await axios.get(\n//             `http://ingress-nginx-controller-admission.kube-system.svc.cluster.local/api/auth/v1/current-user`,\n//             {\n//                 headers: req.headers //  headers includes hosts cookies and all \n//             }\n//         );\n//     }else{\n//         // below code will be executed by the browser only\n//         res = await axios.get('/api/auth/v1/current-user');\n//         // the above request won't work if executed by nextjs server. \n//         // if there is no host address then the axios will  add the current host address \n//         // in this case it is localhost=> which is the container that is running \n//         // nextjs server inside kubernetes cluster. so it will reach out to\n//         // localhost:80/api/auth/v1/current-user. port 80 since we didn't specify port \n//         // it will use 80 by default and inside that container we don't have any\n//         // service listening at port 80\n//     }     \n//     return res.data;\n//  }","map":{"version":3,"sources":["/usr/app/pages/index.js"],"names":["index","currentUser","tickets","getContent","map","t","id","title","price","getInitialProps","context","client","get","data"],"mappings":";;;;;;;;;AACA,IAAMA,KAAK,GAAG,SAARA,KAAQ,OAAyB;AAAA,MAAvBC,WAAuB,QAAvBA,WAAuB;AAAA,MAAXC,OAAW,QAAXA,OAAW;;AAEnC,MAAMC,UAAU,GAAG,SAAbA,UAAa,GAAI;AAClB,WAAOD,OAAO,CAACE,GAAR,CAAY,UAAAC,CAAC,EAAE;AACnB,aAAQ;AAAI,QAAA,GAAG,EAAEA,CAAC,CAACC,EAAX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,SACJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,SAAKD,CAAC,CAACE,KAAP,CADI,EAEJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,SAAKF,CAAC,CAACG,KAAP,CAFI,CAAR;AAIH,KALO,CAAP;AAMJ,GAPD;;AAQA,SACQ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KACI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,eADJ,EAEI;AAAO,IAAA,SAAS,EAAC,OAAjB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KACI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KACI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KACI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,aADJ,EAEI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,aAFJ,CADJ,EAKKL,UAAU,EALf,CADJ,CAFJ,CADR;AAcH,CAxBD;;AA2BAH,KAAK,CAACS,eAAN;AAAA,uEAAwB,iBAAOC,OAAP,EAAeC,MAAf,EAAsBV,WAAtB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBACDU,MAAM,CAACC,GAAP,CAAW,4BAAX,CADC;;AAAA;AACdC,YAAAA,IADc;AAAA,6CAEb;AAACX,cAAAA,OAAO,EAACW,IAAI,CAACA,IAAL,CAAUX;AAAnB,aAFa;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAAxB;;AAAA;AAAA;AAAA;AAAA;;AAIA,eAAeF,KAAf,C,CAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["\nconst index = ({currentUser,tickets})=>{\n    \n    const getContent = ()=>{\n         return tickets.map(t=>{\n            return (<tr key={t.id}>\n                <td>{t.title}</td>\n                <td>{t.price}</td>\n            </tr>)\n        });\n    }\n    return (\n            <div>\n                <h1>Tickets</h1>\n                <table className=\"table\">\n                    <thead>\n                        <tr>\n                            <th>Title</th>\n                            <th>Price</th>\n                        </tr>\n                        {getContent()}\n                    </thead>\n                </table>\n            </div>\n        )\n}; \n\n\nindex.getInitialProps = async (context,client,currentUser)=>{\n    const data = await client.get('/api/ticket/v1/get-tickets');\n    return {tickets:data.data.tickets};\n}\nexport default index;\n\n// IF YOU ARE RUNNING YOUR NEXTJS SERVER IN A DIFFERENT DOMAIN OR DIF KUBERNETES CLUSTER\n// AND SERVICES IN ANOTHER DOMAIN OR K-CLUSTER THEN WE WILL HAVE DIFFERENT DOMAIN FOR \n// SERVICES AND CLIENT IN SUCH CASE WE DON'T NEED TO WORRY ABOUT WHO EXECUTES getInitialProps\n// FUNCTION SINCE IN BOTH CASES WE SEND REQUEST TO SAME DOMAIN WHICH IS DIFFERENT FROM THE \n// CLIENT DOMAIN\n\n// THIS ISSUE IS ONLY KUBERNETES RELATED\n// NOTE\n// ANY REQUEST FROM INSIDE THE REACT COMPONENT WILL BE ISSUED BY THE CLIENT BROWSER\n// ANY REQUEST INSIDE GETINITIALPROPS MAY BE EXECUTED FROM BOTH SERVER OR THE CLIENT BROWSER\n// GETINITIALPROPS\n\n// CASE: INITIATED BY NEXTJS SERVER\n// 1. ON HARD REFRESH \n// 2. CLICKING THE LINK FROM DIFFERENT DOMAIN\n// 3. TYPING URL INTO ADDRESS BAR\n\n// CASE: INITIATED BY CLIENT BROWSER\n// NAVIGATING OR ROUTING FROM ONE PAGE TO ANOTHER WHILE INSIDE THE APP\n// if this network request is made from next js server running inside the kubernetes cluster\n// and next js server is also running in the same cluster then we need to connect to the\n// auth service from the nextjs server\n// TWO WAYS TO CONNECT BETWEEN NEXTJS SERVER AND AUTH SERVICE\n\n// first since they are in same cluster and within same namespace we could simply\n// connect using their clusterip service name but with the risk of exposing the\n// info about our cluster services to the client\n\n// second solution will be to call the ingress-nginx from nextjs server which contains \n// all the logic that will route us to the corresponding service automatically\n// but the ingress-nginx is created in diff namespace than our services which are\n// created in default namespace. service within same namespace can be accessed with service name\n// but cross namespace communication is a different case\n\n// CROSS NAMESPACE COMMUNICATION CAN BE DONE AS\n// http://service-name.namespace-name.svc.cluster.local;\n// or if this syntax is difficult to remember you can also create a external service name\n// that maps to this long name\n\n\n// BELOW CASE ORIGINATES ONLY WHEN THE BROWSER HAS STORED COOKIES FOR THAT DOMAIN\n// IF NO COOKIES FOR THAT DOMAIN ARE STORED THEN WE DON'T HAVE TO WORRY ABOUT IT\n\n// Another issue we are going to run into when network request done by nextjs server is cookies\n// cookies are sent automatically on each request by the browser\n// so on the request for the index.js page the browser sends cookie in the headers to nextjs server\n// thus we need a way to catch this cookie and forward it to the auth service current-user route\n// which depends on the cookies to return the current user\n\n//  index.getInitialProps = async ({req})=>{\n//      let res;\n//      if(typeof window === 'undefined' ){\n//          // window object exists only inside the browser\n//          // so code inside this block will not be executed by browser\n//          // res = await axios.get('http://ingress-nginx-controller-admission.kube-system.svc.cluster.local/api/auth/v1/current-user');\n         \n//          // above will not work since ingress-nginx may have diff routing rules for different domains\n//          // so we also need to specify domain names and ingress-nginx will know which domain rules\n//          // to apply for routing\n//          // const cookie = req.get('Set-Cookie');\n         \n//         // res = await axios.get(\n//         //     `http://ingress-nginx-controller-admission.kube-system.svc.cluster.local/api/auth/v1/current-user`,\n//         //     {\n//         //         headers:{\n//         //             Host:'tickets.dev'\n//         //         }\n//         //     }\n//         // );\n//         res = await axios.get(\n//             `http://ingress-nginx-controller-admission.kube-system.svc.cluster.local/api/auth/v1/current-user`,\n//             {\n//                 headers: req.headers //  headers includes hosts cookies and all \n//             }\n//         );\n//     }else{\n//         // below code will be executed by the browser only\n//         res = await axios.get('/api/auth/v1/current-user');\n//         // the above request won't work if executed by nextjs server. \n//         // if there is no host address then the axios will  add the current host address \n//         // in this case it is localhost=> which is the container that is running \n//         // nextjs server inside kubernetes cluster. so it will reach out to\n//         // localhost:80/api/auth/v1/current-user. port 80 since we didn't specify port \n//         // it will use 80 by default and inside that container we don't have any\n//         // service listening at port 80\n//     }     \n//     return res.data;\n//  }"]},"metadata":{},"sourceType":"module"}