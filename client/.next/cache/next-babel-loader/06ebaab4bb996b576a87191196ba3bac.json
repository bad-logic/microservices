{"ast":null,"code":"var _jsxFileName = \"/usr/app/pages/index.js\";\nimport React from \"react\";\nvar __jsx = React.createElement;\n\nconst index = ({\n  currentUser,\n  tickets\n}) => {\n  return __jsx(\"h1\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 3,\n      columnNumber: 12\n    }\n  }, \"Index\");\n};\n\nindex.getInitialProps = async (context, client, currentUser) => {\n  const data = await client.get('/api/ticket/v1/get-tickets');\n  return {\n    tickets: data.data.tickets\n  };\n};\n\nexport default index; // IF YOU ARE RUNNING YOUR NEXTJS SERVER IN A DIFFERENT DOMAIN OR DIF KUBERNETES CLUSTER\n// AND SERVICES IN ANOTHER DOMAIN OR K-CLUSTER THEN WE WILL HAVE DIFFERENT DOMAIN FOR \n// SERVICES AND CLIENT IN SUCH CASE WE DON'T NEED TO WORRY ABOUT WHO EXECUTES getInitialProps\n// FUNCTION SINCE IN BOTH CASES WE SEND REQUEST TO SAME DOMAIN WHICH IS DIFFERENT FROM THE \n// CLIENT DOMAIN\n// THIS ISSUE IS ONLY KUBERNETES RELATED\n// NOTE\n// ANY REQUEST FROM INSIDE THE REACT COMPONENT WILL BE ISSUED BY THE CLIENT BROWSER\n// ANY REQUEST INSIDE GETINITIALPROPS MAY BE EXECUTED FROM BOTH SERVER OR THE CLIENT BROWSER\n// GETINITIALPROPS\n// CASE: INITIATED BY NEXTJS SERVER\n// 1. ON HARD REFRESH \n// 2. CLICKING THE LINK FROM DIFFERENT DOMAIN\n// 3. TYPING URL INTO ADDRESS BAR\n// CASE: INITIATED BY CLIENT BROWSER\n// NAVIGATING OR ROUTING FROM ONE PAGE TO ANOTHER WHILE INSIDE THE APP\n// if this network request is made from next js server running inside the kubernetes cluster\n// and next js server is also running in the same cluster then we need to connect to the\n// auth service from the nextjs server\n// TWO WAYS TO CONNECT BETWEEN NEXTJS SERVER AND AUTH SERVICE\n// first since they are in same cluster and within same namespace we could simply\n// connect using their clusterip service name but with the risk of exposing the\n// info about our cluster services to the client\n// second solution will be to call the ingress-nginx from nextjs server which contains \n// all the logic that will route us to the corresponding service automatically\n// but the ingress-nginx is created in diff namespace than our services which are\n// created in default namespace. service within same namespace can be accessed with service name\n// but cross namespace communication is a different case\n// CROSS NAMESPACE COMMUNICATION CAN BE DONE AS\n// http://service-name.namespace-name.svc.cluster.local;\n// or if this syntax is difficult to remember you can also create a external service name\n// that maps to this long name\n// BELOW CASE ORIGINATES ONLY WHEN THE BROWSER HAS STORED COOKIES FOR THAT DOMAIN\n// IF NO COOKIES FOR THAT DOMAIN ARE STORED THEN WE DON'T HAVE TO WORRY ABOUT IT\n// Another issue we are going to run into when network request done by nextjs server is cookies\n// cookies are sent automatically on each request by the browser\n// so on the request for the index.js page the browser sends cookie in the headers to nextjs server\n// thus we need a way to catch this cookie and forward it to the auth service current-user route\n// which depends on the cookies to return the current user\n//  index.getInitialProps = async ({req})=>{\n//      let res;\n//      if(typeof window === 'undefined' ){\n//          // window object exists only inside the browser\n//          // so code inside this block will not be executed by browser\n//          // res = await axios.get('http://ingress-nginx-controller-admission.kube-system.svc.cluster.local/api/auth/v1/current-user');\n//          // above will not work since ingress-nginx may have diff routing rules for different domains\n//          // so we also need to specify domain names and ingress-nginx will know which domain rules\n//          // to apply for routing\n//          // const cookie = req.get('Set-Cookie');\n//         // res = await axios.get(\n//         //     `http://ingress-nginx-controller-admission.kube-system.svc.cluster.local/api/auth/v1/current-user`,\n//         //     {\n//         //         headers:{\n//         //             Host:'tickets.dev'\n//         //         }\n//         //     }\n//         // );\n//         res = await axios.get(\n//             `http://ingress-nginx-controller-admission.kube-system.svc.cluster.local/api/auth/v1/current-user`,\n//             {\n//                 headers: req.headers //  headers includes hosts cookies and all \n//             }\n//         );\n//     }else{\n//         // below code will be executed by the browser only\n//         res = await axios.get('/api/auth/v1/current-user');\n//         // the above request won't work if executed by nextjs server. \n//         // if there is no host address then the axios will  add the current host address \n//         // in this case it is localhost=> which is the container that is running \n//         // nextjs server inside kubernetes cluster. so it will reach out to\n//         // localhost:80/api/auth/v1/current-user. port 80 since we didn't specify port \n//         // it will use 80 by default and inside that container we don't have any\n//         // service listening at port 80\n//     }     \n//     return res.data;\n//  }","map":{"version":3,"sources":["/usr/app/pages/index.js"],"names":["index","currentUser","tickets","getInitialProps","context","client","data","get"],"mappings":";;;;AACA,MAAMA,KAAK,GAAG,CAAC;AAACC,EAAAA,WAAD;AAAaC,EAAAA;AAAb,CAAD,KAAyB;AACnC,SAAO;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,aAAP;AACH,CAFD;;AAKAF,KAAK,CAACG,eAAN,GAAwB,OAAOC,OAAP,EAAeC,MAAf,EAAsBJ,WAAtB,KAAoC;AACxD,QAAMK,IAAI,GAAG,MAAMD,MAAM,CAACE,GAAP,CAAW,4BAAX,CAAnB;AACA,SAAO;AAACL,IAAAA,OAAO,EAACI,IAAI,CAACA,IAAL,CAAUJ;AAAnB,GAAP;AACH,CAHD;;AAIA,eAAeF,KAAf,C,CAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["\nconst index = ({currentUser,tickets})=>{\n    return <h1>Index</h1>\n}; \n\n\nindex.getInitialProps = async (context,client,currentUser)=>{\n    const data = await client.get('/api/ticket/v1/get-tickets');\n    return {tickets:data.data.tickets};\n}\nexport default index;\n\n// IF YOU ARE RUNNING YOUR NEXTJS SERVER IN A DIFFERENT DOMAIN OR DIF KUBERNETES CLUSTER\n// AND SERVICES IN ANOTHER DOMAIN OR K-CLUSTER THEN WE WILL HAVE DIFFERENT DOMAIN FOR \n// SERVICES AND CLIENT IN SUCH CASE WE DON'T NEED TO WORRY ABOUT WHO EXECUTES getInitialProps\n// FUNCTION SINCE IN BOTH CASES WE SEND REQUEST TO SAME DOMAIN WHICH IS DIFFERENT FROM THE \n// CLIENT DOMAIN\n\n// THIS ISSUE IS ONLY KUBERNETES RELATED\n// NOTE\n// ANY REQUEST FROM INSIDE THE REACT COMPONENT WILL BE ISSUED BY THE CLIENT BROWSER\n// ANY REQUEST INSIDE GETINITIALPROPS MAY BE EXECUTED FROM BOTH SERVER OR THE CLIENT BROWSER\n// GETINITIALPROPS\n\n// CASE: INITIATED BY NEXTJS SERVER\n// 1. ON HARD REFRESH \n// 2. CLICKING THE LINK FROM DIFFERENT DOMAIN\n// 3. TYPING URL INTO ADDRESS BAR\n\n// CASE: INITIATED BY CLIENT BROWSER\n// NAVIGATING OR ROUTING FROM ONE PAGE TO ANOTHER WHILE INSIDE THE APP\n// if this network request is made from next js server running inside the kubernetes cluster\n// and next js server is also running in the same cluster then we need to connect to the\n// auth service from the nextjs server\n// TWO WAYS TO CONNECT BETWEEN NEXTJS SERVER AND AUTH SERVICE\n\n// first since they are in same cluster and within same namespace we could simply\n// connect using their clusterip service name but with the risk of exposing the\n// info about our cluster services to the client\n\n// second solution will be to call the ingress-nginx from nextjs server which contains \n// all the logic that will route us to the corresponding service automatically\n// but the ingress-nginx is created in diff namespace than our services which are\n// created in default namespace. service within same namespace can be accessed with service name\n// but cross namespace communication is a different case\n\n// CROSS NAMESPACE COMMUNICATION CAN BE DONE AS\n// http://service-name.namespace-name.svc.cluster.local;\n// or if this syntax is difficult to remember you can also create a external service name\n// that maps to this long name\n\n\n// BELOW CASE ORIGINATES ONLY WHEN THE BROWSER HAS STORED COOKIES FOR THAT DOMAIN\n// IF NO COOKIES FOR THAT DOMAIN ARE STORED THEN WE DON'T HAVE TO WORRY ABOUT IT\n\n// Another issue we are going to run into when network request done by nextjs server is cookies\n// cookies are sent automatically on each request by the browser\n// so on the request for the index.js page the browser sends cookie in the headers to nextjs server\n// thus we need a way to catch this cookie and forward it to the auth service current-user route\n// which depends on the cookies to return the current user\n\n//  index.getInitialProps = async ({req})=>{\n//      let res;\n//      if(typeof window === 'undefined' ){\n//          // window object exists only inside the browser\n//          // so code inside this block will not be executed by browser\n//          // res = await axios.get('http://ingress-nginx-controller-admission.kube-system.svc.cluster.local/api/auth/v1/current-user');\n         \n//          // above will not work since ingress-nginx may have diff routing rules for different domains\n//          // so we also need to specify domain names and ingress-nginx will know which domain rules\n//          // to apply for routing\n//          // const cookie = req.get('Set-Cookie');\n         \n//         // res = await axios.get(\n//         //     `http://ingress-nginx-controller-admission.kube-system.svc.cluster.local/api/auth/v1/current-user`,\n//         //     {\n//         //         headers:{\n//         //             Host:'tickets.dev'\n//         //         }\n//         //     }\n//         // );\n//         res = await axios.get(\n//             `http://ingress-nginx-controller-admission.kube-system.svc.cluster.local/api/auth/v1/current-user`,\n//             {\n//                 headers: req.headers //  headers includes hosts cookies and all \n//             }\n//         );\n//     }else{\n//         // below code will be executed by the browser only\n//         res = await axios.get('/api/auth/v1/current-user');\n//         // the above request won't work if executed by nextjs server. \n//         // if there is no host address then the axios will  add the current host address \n//         // in this case it is localhost=> which is the container that is running \n//         // nextjs server inside kubernetes cluster. so it will reach out to\n//         // localhost:80/api/auth/v1/current-user. port 80 since we didn't specify port \n//         // it will use 80 by default and inside that container we don't have any\n//         // service listening at port 80\n//     }     \n//     return res.data;\n//  }"]},"metadata":{},"sourceType":"module"}