{"ast":null,"code":"var _jsxFileName = \"/usr/app/pages/index.js\";\nimport React from \"react\";\nvar __jsx = React.createElement;\n// import axios from 'axios';\nimport buildClient from '../api/build-client'; // IF YOU ARE RUNNING YOUR NEXTJS SERVER IN A DIFFERENT DOMAIN OR DIF KUBERNETES CLUSTER\n// AND SERVICES IN ANOTHER DOMAIN OR K-CLUSTER THEN WE WILL HAVE DIFFERENT DOMAIN FOR \n// SERVICES AND CLIENT IN SUCH CASE WE DON'T NEED TO WORRY ABOUT WHO EXECUTES getInitialProps\n// FUNCTION SINCE IN BOTH CASES WE SEND REQUEST TO SAME DOMAIN WHICH IS DIFFERENT FROM THE \n// CLIENT DOMAIN\n// THIS ISSUE IS ONLY KUBERNETES RELATED\n// NOTE\n// ANY REQUEST FROM INSIDE THE REACT COMPONENT WILL BE ISSUED BY THE CLIENT BROWSER\n// ANY REQUEST INSIDE GETINITIALPROPS MAY BE EXECUTED FROM BOTH SERVER OR THE CLIENT BROWSER\n// GETINITIALPROPS\n// CASE: INITIATED BY NEXTJS SERVER\n// 1. ON HARD REFRESH \n// 2. CLICKING THE LINK FROM DIFFERENT DOMAIN\n// 3. TYPING URL INTO ADDRESS BAR\n// CASE: INITIATED BY CLIENT BROWSER\n// NAVIGATING OR ROUTING FROM ONE PAGE TO ANOTHER WHILE INSIDE THE APP\n\nconst index = ({\n  currentUser\n}) => {\n  return __jsx(\"h1\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 25,\n      columnNumber: 12\n    }\n  }, \"Index\");\n}; // specific to next js\n// code inside getInitialProps function will be executed inside nextjs server which is in kubernets cluster\n// or may be from the client browser depends on the situation noted in above note\n// if this network request is made from next js server running inside the kubernetes cluster\n// and next js server is also running in the same cluster then we need to connect to the\n// auth service from the nextjs server\n// TWO WAYS TO CONNECT BETWEEN NEXTJS SERVER AND AUTH SERVICE\n// first since they are in same cluster and within same namespace we could simply\n// connect using their clusterip service name but with the risk of exposing the\n// info about our cluster services to the client\n// second solution will be to call the ingress-nginx from nextjs server which contains \n// all the logic that will route us to the corresponding service automatically\n// but the ingress-nginx is created in diff namespace than our services which are\n// created in default namespace. service within same namespace can be accessed with service name\n// but cross namespace communication is a different case\n// CROSS NAMESPACE COMMUNICATION CAN BE DONE AS\n// http://service-name.namespace-name.svc.cluster.local;\n// or if this syntax is difficult to remember you can also create a external service name\n// that maps to this long name\n// BELOW CASE ORIGINATES ONLY WHEN THE BROWSER HAS STORED COOKIES FOR THAT DOMAIN\n// IF NO COOKIES FOR THAT DOMAIN ARE STORED THEN WE DON'T HAVE TO WORRY ABOUT IT\n// Another issue we are going to run into when network request done by nextjs server is cookies\n// cookies are sent automatically on each request by the browser\n// so on the request for the index.js page the browser sends cookie in the headers to nextjs server\n// thus we need a way to catch this cookie and forward it to the auth service current-user route\n// which depends on the cookies to return the current user\n//  index.getInitialProps = async ({req})=>{\n//      let res;\n//      if(typeof window === 'undefined' ){\n//          // window object exists only inside the browser\n//          // so code inside this block will not be executed by browser\n//          // res = await axios.get('http://ingress-nginx-controller-admission.kube-system.svc.cluster.local/api/auth/v1/current-user');\n//          // above will not work since ingress-nginx may have diff routing rules for different domains\n//          // so we also need to specify domain names and ingress-nginx will know which domain rules\n//          // to apply for routing\n//          // const cookie = req.get('Set-Cookie');\n//         // res = await axios.get(\n//         //     `http://ingress-nginx-controller-admission.kube-system.svc.cluster.local/api/auth/v1/current-user`,\n//         //     {\n//         //         headers:{\n//         //             Host:'tickets.dev'\n//         //         }\n//         //     }\n//         // );\n//         res = await axios.get(\n//             // cross namespace communication not working so directly using clusterIp service\n//             `http://ingress-nginx-controller-admission.kube-system.svc.cluster.local/api/auth/v1/current-user`,\n//             {\n//                 headers: req.headers //  headers includes hosts cookies and all \n//             }\n//         );\n//     }else{\n//         // below code will be executed by the browser only\n//         res = await axios.get('/api/auth/v1/current-user');\n//         // the above request won't work if executed by nextjs server. \n//         // if there is no host address then the axios will  add the current host address \n//         // in this case it is localhost=> which is the container that is running \n//         // nextjs server inside kubernetes cluster. so it will reach out to\n//         // localhost:80/api/auth/v1/current-user. port 80 since we didn.t specify port \n//         // it will use 80 by default and inside that container we don't have any\n//         // service listening at port 80\n//     }     \n//     return res.data;\n//  }\n\n\nindex.getInitialProps = async context => {\n  const client = buildClient(context.req, 'auth');\n  const res = await client.get('/api/auth/v1/current-user');\n  return res.data;\n};\n\nexport default index;","map":{"version":3,"sources":["/usr/app/pages/index.js"],"names":["buildClient","index","currentUser","getInitialProps","context","client","req","res","get","data"],"mappings":";;;AAAA;AAEA,OAAOA,WAAP,MAAwB,qBAAxB,C,CAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA,MAAMC,KAAK,GAAG,CAAC;AAACC,EAAAA;AAAD,CAAD,KAAiB;AAC3B,SAAO;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,aAAP;AACH,CAFD,C,CAIA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEAD,KAAK,CAACE,eAAN,GAAwB,MAAOC,OAAP,IAAiB;AACrC,QAAMC,MAAM,GAAGL,WAAW,CAACI,OAAO,CAACE,GAAT,EAAa,MAAb,CAA1B;AACA,QAAMC,GAAG,GAAG,MAAMF,MAAM,CAACG,GAAP,CAAW,2BAAX,CAAlB;AACA,SAAOD,GAAG,CAACE,IAAX;AACH,CAJD;;AAKA,eAAeR,KAAf","sourcesContent":["// import axios from 'axios';\n\nimport buildClient from '../api/build-client';\n\n// IF YOU ARE RUNNING YOUR NEXTJS SERVER IN A DIFFERENT DOMAIN OR DIF KUBERNETES CLUSTER\n// AND SERVICES IN ANOTHER DOMAIN OR K-CLUSTER THEN WE WILL HAVE DIFFERENT DOMAIN FOR \n// SERVICES AND CLIENT IN SUCH CASE WE DON'T NEED TO WORRY ABOUT WHO EXECUTES getInitialProps\n// FUNCTION SINCE IN BOTH CASES WE SEND REQUEST TO SAME DOMAIN WHICH IS DIFFERENT FROM THE \n// CLIENT DOMAIN\n\n// THIS ISSUE IS ONLY KUBERNETES RELATED\n// NOTE\n// ANY REQUEST FROM INSIDE THE REACT COMPONENT WILL BE ISSUED BY THE CLIENT BROWSER\n// ANY REQUEST INSIDE GETINITIALPROPS MAY BE EXECUTED FROM BOTH SERVER OR THE CLIENT BROWSER\n// GETINITIALPROPS\n// CASE: INITIATED BY NEXTJS SERVER\n// 1. ON HARD REFRESH \n// 2. CLICKING THE LINK FROM DIFFERENT DOMAIN\n// 3. TYPING URL INTO ADDRESS BAR\n\n// CASE: INITIATED BY CLIENT BROWSER\n// NAVIGATING OR ROUTING FROM ONE PAGE TO ANOTHER WHILE INSIDE THE APP\n\nconst index = ({currentUser})=>{\n    return <h1>Index</h1>\n}; \n\n// specific to next js\n// code inside getInitialProps function will be executed inside nextjs server which is in kubernets cluster\n// or may be from the client browser depends on the situation noted in above note\n\n// if this network request is made from next js server running inside the kubernetes cluster\n// and next js server is also running in the same cluster then we need to connect to the\n// auth service from the nextjs server\n// TWO WAYS TO CONNECT BETWEEN NEXTJS SERVER AND AUTH SERVICE\n\n// first since they are in same cluster and within same namespace we could simply\n// connect using their clusterip service name but with the risk of exposing the\n// info about our cluster services to the client\n\n// second solution will be to call the ingress-nginx from nextjs server which contains \n// all the logic that will route us to the corresponding service automatically\n// but the ingress-nginx is created in diff namespace than our services which are\n// created in default namespace. service within same namespace can be accessed with service name\n// but cross namespace communication is a different case\n\n// CROSS NAMESPACE COMMUNICATION CAN BE DONE AS\n// http://service-name.namespace-name.svc.cluster.local;\n// or if this syntax is difficult to remember you can also create a external service name\n// that maps to this long name\n\n\n// BELOW CASE ORIGINATES ONLY WHEN THE BROWSER HAS STORED COOKIES FOR THAT DOMAIN\n// IF NO COOKIES FOR THAT DOMAIN ARE STORED THEN WE DON'T HAVE TO WORRY ABOUT IT\n\n// Another issue we are going to run into when network request done by nextjs server is cookies\n// cookies are sent automatically on each request by the browser\n// so on the request for the index.js page the browser sends cookie in the headers to nextjs server\n// thus we need a way to catch this cookie and forward it to the auth service current-user route\n// which depends on the cookies to return the current user\n\n//  index.getInitialProps = async ({req})=>{\n//      let res;\n//      if(typeof window === 'undefined' ){\n//          // window object exists only inside the browser\n//          // so code inside this block will not be executed by browser\n//          // res = await axios.get('http://ingress-nginx-controller-admission.kube-system.svc.cluster.local/api/auth/v1/current-user');\n         \n//          // above will not work since ingress-nginx may have diff routing rules for different domains\n//          // so we also need to specify domain names and ingress-nginx will know which domain rules\n//          // to apply for routing\n//          // const cookie = req.get('Set-Cookie');\n         \n//         // res = await axios.get(\n//         //     `http://ingress-nginx-controller-admission.kube-system.svc.cluster.local/api/auth/v1/current-user`,\n//         //     {\n//         //         headers:{\n//         //             Host:'tickets.dev'\n//         //         }\n//         //     }\n//         // );\n//         res = await axios.get(\n//             // cross namespace communication not working so directly using clusterIp service\n//             `http://ingress-nginx-controller-admission.kube-system.svc.cluster.local/api/auth/v1/current-user`,\n//             {\n//                 headers: req.headers //  headers includes hosts cookies and all \n//             }\n//         );\n//     }else{\n//         // below code will be executed by the browser only\n//         res = await axios.get('/api/auth/v1/current-user');\n//         // the above request won't work if executed by nextjs server. \n//         // if there is no host address then the axios will  add the current host address \n//         // in this case it is localhost=> which is the container that is running \n//         // nextjs server inside kubernetes cluster. so it will reach out to\n//         // localhost:80/api/auth/v1/current-user. port 80 since we didn.t specify port \n//         // it will use 80 by default and inside that container we don't have any\n//         // service listening at port 80\n//     }     \n//     return res.data;\n//  }\n\nindex.getInitialProps = async (context)=>{\n    const client = buildClient(context.req,'auth');\n    const res = await client.get('/api/auth/v1/current-user');\n    return res.data;\n}\nexport default index;"]},"metadata":{},"sourceType":"module"}